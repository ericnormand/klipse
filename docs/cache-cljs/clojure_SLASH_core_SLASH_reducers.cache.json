["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",["~$reduce","~$take","~$map","~$mapcat","~$cat","~$take-while","~$remove","~$drop","~$flatten","~$filter"]],"~:name","~$clojure.core.reducers","~:imports",null,"~:requires",["^ ","~$core","~$cljs.core","^F","^F"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","^7",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^B","~:line",33,"~:column",7,"~:end-line",33,"~:end-column",13,"~:arglists",["~#list",["~$quote",["^R",[["~$f","~$coll"],["~$f","~$init","^T"]]]]],"~:doc","Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv","~:top-fn",["^ ","~:variadic",false,"~:max-fixed-arity",3,"~:method-params",["^R",[["~$f","^T"],["~$f","^U","^T"]]],"^Q",["^R",[["~$f","^T"],["~$f","^U","^T"]]],"~:arglists-meta",["^R",[null,null]]]],"^A","~$clojure.core.reducers/reduce","^X",false,"^L","clojure/core/reducers.cljs","^P",13,"^W",["^ ","^X",false,"^Y",3,"^Z",["^R",[["~$f","^T"],["~$f","^U","^T"]]],"^Q",["^R",[["~$f","^T"],["~$f","^U","^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[["~$f","^T"],["~$f","^U","^T"]]],"~:protocol-impl",null,"^[",["^R",[null,null]],"^N",1,"^M",33,"^O",33,"^Y",3,"~:fn-var",true,"^Q",["^R",[["~$f","^T"],["~$f","^U","^T"]]],"^V","Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv"],"^8",["^ ","^J",null,"^K",["^ ","^L","^B","^M",164,"^N",13,"^O",164,"^P",17,"^Q",["^R",["^S",["^R",[["~$n"],["~$n","^T"]]]]],"^V","Ends the reduction of coll after consuming n values.","^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["~$n"],["~$n","^T"]]],"^Q",["^R",[["~$n"],["~$n","^T"]]],"^[",["^R",[null,null]]]],"^A","~$clojure.core.reducers/take","^X",false,"^L","clojure/core/reducers.cljs","^P",17,"^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["~$n"],["~$n","^T"]]],"^Q",["^R",[["~$n"],["~$n","^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[["~$n"],["~$n","^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",164,"^O",164,"^Y",2,"^12",true,"^Q",["^R",[["~$n"],["~$n","^T"]]],"^V","Ends the reduction of coll after consuming n values."],"^9",["^ ","^J",null,"^K",["^ ","^L","^B","^M",96,"^N",13,"^O",96,"^P",16,"^Q",["^R",["^S",["^R",[["~$f"],["~$f","^T"]]]]],"^V","Applies f to every value in the reduction of coll. Foldable.","^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["~$f"],["~$f","^T"]]],"^Q",["^R",[["~$f"],["~$f","^T"]]],"^[",["^R",[null,null]]]],"^A","~$clojure.core.reducers/map","^X",false,"^L","clojure/core/reducers.cljs","^P",16,"^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["~$f"],["~$f","^T"]]],"^Q",["^R",[["~$f"],["~$f","^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[["~$f"],["~$f","^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",96,"^O",96,"^Y",2,"^12",true,"^Q",["^R",[["~$f"],["~$f","^T"]]],"^V","Applies f to every value in the reduction of coll. Foldable."],"~$foldcat",["^ ","^J",null,"^K",["^ ","^L","^B","^M",237,"^N",7,"^O",237,"^P",14,"^Q",["^R",["^S",["^R",[["^T"]]]]],"^V","Equivalent to (fold cat append! coll)"],"^A","~$clojure.core.reducers/foldcat","^X",false,"^L","clojure/core/reducers.cljs","^P",14,"^Z",["^R",[["^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",237,"^O",237,"^Y",1,"^12",true,"^Q",["^R",["^S",["^R",[["^T"]]]]],"^V","Equivalent to (fold cat append! coll)"],"~$reducer",["^ ","^J",null,"^K",["^ ","^L","^B","^M",66,"^N",7,"^O",66,"^P",14,"^Q",["^R",["^S",["^R",[["^T","~$xf"]]]]],"^V","Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."],"^A","~$clojure.core.reducers/reducer","^X",false,"^L","clojure/core/reducers.cljs","^P",14,"^Z",["^R",[["^T","^18"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",66,"^O",66,"^Y",2,"^12",true,"^Q",["^R",["^S",["^R",[["^T","^18"]]]]],"^V","Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."],"^:",["^ ","^J",null,"^K",["^ ","^L","^B","^M",106,"^N",13,"^O",106,"^P",19,"^Q",["^R",["^S",["^R",[["~$f"],["~$f","^T"]]]]],"^V","Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.","^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["~$f"],["~$f","^T"]]],"^Q",["^R",[["~$f"],["~$f","^T"]]],"^[",["^R",[null,null]]]],"^A","~$clojure.core.reducers/mapcat","^X",false,"^L","clojure/core/reducers.cljs","^P",19,"^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["~$f"],["~$f","^T"]]],"^Q",["^R",[["~$f"],["~$f","^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[["~$f"],["~$f","^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",106,"^O",106,"^Y",2,"^12",true,"^Q",["^R",[["~$f"],["~$f","^T"]]],"^V","Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."],"~$->t_clojure$core$reducers2362",["^ ","^J",null,"^K",["^ ","~:anonymous",true,"~:protocols",["^6",["~$cljs.core/IWithMeta","~$cljs.core/IMeta","~$cljs.core/IReduce","~$clojure.core.reducers/CollFold"]],"~:skip-protocol-flag",["^6",["^1>","^1?","^1@"]],"~:factory","~:positional","^Q",["^R",["^S",["^R",[["^T","^18","~$meta2363"]]]]],"^L",null],"^1=",["^6",["^1>","^1?","^1@","^1A"]],"^A","~$clojure.core.reducers/->t_clojure$core$reducers2362","^X",false,"^L","clojure/core/reducers.cljs","^Z",["^R",[["^T","^18","^1E"]]],"^11",null,"^[",["^R",[null,null]],"^1<",true,"^N",6,"^1C","^1D","^M",85,"^Y",3,"^12",true,"^Q",["^R",["^S",["^R",[["^T","^18","^1E"]]]]],"^1B",["^6",["^1>","^1?","^1@"]]],"~$->t_clojure$core$reducers2359",["^ ","^J",null,"^K",["^ ","^1<",true,"^1=",["^6",["^1>","^1?","^1@"]],"^1B",["^6",["^1>","^1?","^1@"]],"^1C","^1D","^Q",["^R",["^S",["^R",[["^T","^18","~$meta2360"]]]]],"^L",null],"^1=",["^6",["^1>","^1?","^1@"]],"^A","~$clojure.core.reducers/->t_clojure$core$reducers2359","^X",false,"^L","clojure/core/reducers.cljs","^Z",["^R",[["^T","^18","^1H"]]],"^11",null,"^[",["^R",[null,null]],"^1<",true,"^N",6,"^1C","^1D","^M",72,"^Y",3,"^12",true,"^Q",["^R",["^S",["^R",[["^T","^18","^1H"]]]]],"^1B",["^6",["^1>","^1?","^1@"]]],"^;",["^ ","^J",null,"^K",["^ ","^L","^B","^M",213,"^N",7,"^O",213,"^P",10,"^Q",["^R",["^S",["^R",[[],["~$ctor"],["~$left","~$right"]]]]],"^V","A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.","^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[[],["^1J"],["^1K","^1L"]]],"^Q",["^R",[[],["^1J"],["^1K","^1L"]]],"^[",["^R",[null,null,null]]]],"^A","~$clojure.core.reducers/cat","^X",false,"^L","clojure/core/reducers.cljs","^P",10,"^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[[],["^1J"],["^1K","^1L"]]],"^Q",["^R",[[],["^1J"],["^1K","^1L"]]],"^[",["^R",[null,null,null]]],"^Z",["^R",[[],["^1J"],["^1K","^1L"]]],"^11",null,"^[",["^R",[null,null,null]],"^N",1,"^M",213,"^O",213,"^Y",2,"^12",true,"^Q",["^R",[[],["^1J"],["^1K","^1L"]]],"^V","A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat."],"^<",["^ ","^J",null,"^K",["^ ","^L","^B","^M",152,"^N",13,"^O",152,"^P",23,"^Q",["^R",["^S",["^R",[["~$pred"],["^1N","^T"]]]]],"^V","Ends the reduction of coll when (pred val) returns logical false.","^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["^1N"],["^1N","^T"]]],"^Q",["^R",[["^1N"],["^1N","^T"]]],"^[",["^R",[null,null]]]],"^A","~$clojure.core.reducers/take-while","^X",false,"^L","clojure/core/reducers.cljs","^P",23,"^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["^1N"],["^1N","^T"]]],"^Q",["^R",[["^1N"],["^1N","^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[["^1N"],["^1N","^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",152,"^O",152,"^Y",2,"^12",true,"^Q",["^R",[["^1N"],["^1N","^T"]]],"^V","Ends the reduction of coll when (pred val) returns logical false."],"^=",["^ ","^J",null,"^K",["^ ","^L","^B","^M",145,"^N",13,"^O",145,"^P",19,"^Q",["^R",["^S",["^R",[["^1N"],["^1N","^T"]]]]],"^V","Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.","^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["^1N"],["^1N","^T"]]],"^Q",["^R",[["^1N"],["^1N","^T"]]],"^[",["^R",[null,null]]]],"^A","~$clojure.core.reducers/remove","^X",false,"^L","clojure/core/reducers.cljs","^P",19,"^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["^1N"],["^1N","^T"]]],"^Q",["^R",[["^1N"],["^1N","^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[["^1N"],["^1N","^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",145,"^O",145,"^Y",2,"^12",true,"^Q",["^R",[["^1N"],["^1N","^T"]]],"^V","Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."],"~$fjjoin",["^ ","^J",null,"^K",["^ ","^L","^B","^M",29,"^N",8,"^O",29,"^P",14,"~:private",true,"^Q",["^R",["^S",["^R",[["~$task"]]]]]],"^1R",true,"^A","~$clojure.core.reducers/fjjoin","^X",false,"^L","clojure/core/reducers.cljs","^P",14,"^Z",["^R",[["^1S"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",29,"^O",29,"^Y",1,"^12",true,"^Q",["^R",["^S",["^R",[["^1S"]]]]]],"~$fjinvoke",["^ ","^J",null,"^K",["^ ","^L","^B","^M",23,"^N",8,"^O",23,"^P",16,"^1R",true,"^Q",["^R",["^S",["^R",[["~$f"]]]]]],"^1R",true,"^A","~$clojure.core.reducers/fjinvoke","^X",false,"^L","clojure/core/reducers.cljs","^P",16,"^Z",["^R",[["~$f"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",23,"^O",23,"^Y",1,"^12",true,"^Q",["^R",["^S",["^R",[["~$f"]]]]]],"~$CollFold",["^ ","^K",["^ ","~:protocol-symbol",true,"^L","^B","^P",22,"^N",14,"^M",46,"~:protocol-info",["^ ","~:methods",["^ ","~$coll-fold",[["^T","~$n","~$combinef","~$reducef"]]]],"^O",46,"^V",null,"~:jsdoc",["^R",["@interface"]]],"^1X",true,"^A","^1A","^L","clojure/core/reducers.cljs","^P",22,"^N",1,"^M",46,"^1Y",["^ ","^1Z",["^ ","^1[",[["^T","~$n","^20","^21"]]]],"~:info",null,"^O",46,"~:tag","~$any","~:impls",["^6",["~$clojure.core.reducers/t_clojure$core$reducers2362","~$clojure.core.reducers/Cat",null,"~$object","~$cljs.core/PersistentVector"]],"^V",null,"^22",["^R",["@interface"]]],"~$folder",["^ ","^J",null,"^K",["^ ","^L","^B","^M",79,"^N",7,"^O",79,"^P",13,"^Q",["^R",["^S",["^R",[["^T","^18"]]]]],"^V","Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."],"^A","~$clojure.core.reducers/folder","^X",false,"^L","clojure/core/reducers.cljs","^P",13,"^Z",["^R",[["^T","^18"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",79,"^O",79,"^Y",2,"^12",true,"^Q",["^R",["^S",["^R",[["^T","^18"]]]]],"^V","Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn."],"~$append!",["^ ","^J",null,"^K",["^ ","^L","^B","^M",232,"^N",7,"^O",232,"^P",14,"^Q",["^R",["^S",["^R",[["~$acc","~$x"]]]]],"^V",".adds x to acc and returns acc"],"^A","~$clojure.core.reducers/append!","^X",false,"^L","clojure/core/reducers.cljs","^P",14,"^Z",["^R",[["^2>","~$x"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",232,"^O",232,"^Y",2,"^12",true,"^Q",["^R",["^S",["^R",[["^2>","~$x"]]]]],"^V",".adds x to acc and returns acc"],"~$->Cat",["^ ","^J",null,"^K",["^ ","^1=",["^6",["~$cljs.core/ICounted","~$cljs.core/ISeqable","^1@","^1A"]],"^L","^B","^P",13,"^N",10,"^1C","^1D","^M",193,"^O",193,"^Q",["^R",["^S",["^R",[["~$cnt","^1K","^1L"]]]]],"^1B",["^6",["^2A","^2B","^1@"]]],"^1=",["^6",["^2A","^2B","^1@","^1A"]],"^A","~$clojure.core.reducers/->Cat","^X",false,"^L","clojure/core/reducers.cljs","^P",13,"^Z",["^R",[["^2C","^1K","^1L"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^1C","^1D","^M",193,"^O",193,"^Y",3,"^12",true,"^Q",["^R",["^S",["^R",[["^2C","^1K","^1L"]]]]],"^1B",["^6",["^2A","^2B","^1@"]]],"^>",["^ ","^J",null,"^K",["^ ","^L","^B","^M",178,"^N",13,"^O",178,"^P",17,"^Q",["^R",["^S",["^R",[["~$n"],["~$n","^T"]]]]],"^V","Elides the first n values from the reduction of coll.","^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["~$n"],["~$n","^T"]]],"^Q",["^R",[["~$n"],["~$n","^T"]]],"^[",["^R",[null,null]]]],"^A","~$clojure.core.reducers/drop","^X",false,"^L","clojure/core/reducers.cljs","^P",17,"^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["~$n"],["~$n","^T"]]],"^Q",["^R",[["~$n"],["~$n","^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[["~$n"],["~$n","^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",178,"^O",178,"^Y",2,"^12",true,"^Q",["^R",[["~$n"],["~$n","^T"]]],"^V","Elides the first n values from the reduction of coll."],"~$fold",["^ ","^J",null,"^K",["^ ","^L","^B","^M",49,"^N",7,"^O",49,"^P",11,"^Q",["^R",["^S",["^R",[["^21","^T"],["^20","^21","^T"],["~$n","^20","^21","^T"]]]]],"^V","Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented.","^W",["^ ","^X",false,"^Y",4,"^Z",["^R",[["^21","^T"],["^20","^21","^T"],["~$n","^20","^21","^T"]]],"^Q",["^R",[["^21","^T"],["^20","^21","^T"],["~$n","^20","^21","^T"]]],"^[",["^R",[null,null,null]]]],"^A","~$clojure.core.reducers/fold","^X",false,"^L","clojure/core/reducers.cljs","^P",11,"^W",["^ ","^X",false,"^Y",4,"^Z",["^R",[["^21","^T"],["^20","^21","^T"],["~$n","^20","^21","^T"]]],"^Q",["^R",[["^21","^T"],["^20","^21","^T"],["~$n","^20","^21","^T"]]],"^[",["^R",[null,null,null]]],"^Z",["^R",[["^21","^T"],["^20","^21","^T"],["~$n","^20","^21","^T"]]],"^11",null,"^[",["^R",[null,null,null]],"^N",1,"^M",49,"^O",49,"^Y",4,"^12",true,"^Q",["^R",[["^21","^T"],["^20","^21","^T"],["~$n","^20","^21","^T"]]],"^V","Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented."],"~$Cat",["^ ","~:num-fields",3,"^1=",["^6",["^2A","^2B","^1@","^1A"]],"^A","^28","^L","clojure/core/reducers.cljs","^P",13,"~:type",true,"^N",10,"^M",193,"~:record",false,"^O",193,"^1B",["^6",["^2A","^2B","^1@"]]],"~$t_clojure$core$reducers2362",["^ ","^2I",3,"^1=",["^6",["^1>","^1?","^1@","^1A"]],"^A","^27","^L","clojure/core/reducers.cljs","^2J",true,"^1<",true,"^N",6,"^M",85,"^2K",false,"^1B",["^6",["^1>","^1?","^1@"]]],"^?",["^ ","^J",null,"^K",["^ ","^L","^B","^M",130,"^N",13,"^O",130,"^P",20,"^Q",["^R",["^S",["^R",[[],["^T"]]]]],"^V","Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.","^W",["^ ","^X",false,"^Y",1,"^Z",["^R",[[],["^T"]]],"^Q",["^R",[[],["^T"]]],"^[",["^R",[null,null]]]],"^A","~$clojure.core.reducers/flatten","^X",false,"^L","clojure/core/reducers.cljs","^P",20,"^W",["^ ","^X",false,"^Y",1,"^Z",["^R",[[],["^T"]]],"^Q",["^R",[[],["^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[[],["^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",130,"^O",130,"^Y",1,"^12",true,"^Q",["^R",[[],["^T"]]],"^V","Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."],"^@",["^ ","^J",null,"^K",["^ ","^L","^B","^M",117,"^N",13,"^O",117,"^P",19,"^Q",["^R",["^S",["^R",[["^1N"],["^1N","^T"]]]]],"^V","Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.","^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["^1N"],["^1N","^T"]]],"^Q",["^R",[["^1N"],["^1N","^T"]]],"^[",["^R",[null,null]]]],"^A","~$clojure.core.reducers/filter","^X",false,"^L","clojure/core/reducers.cljs","^P",19,"^W",["^ ","^X",false,"^Y",2,"^Z",["^R",[["^1N"],["^1N","^T"]]],"^Q",["^R",[["^1N"],["^1N","^T"]]],"^[",["^R",[null,null]]],"^Z",["^R",[["^1N"],["^1N","^T"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",117,"^O",117,"^Y",2,"^12",true,"^Q",["^R",[["^1N"],["^1N","^T"]]],"^V","Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."],"~$fjtask",["^ ","^J",null,"^K",["^ ","^L","^B","^M",20,"^N",8,"^O",20,"^P",14,"^1R",true,"^Q",["^R",["^S",["^R",[["~$f"]]]]]],"^1R",true,"^A","~$clojure.core.reducers/fjtask","^X",false,"^L","clojure/core/reducers.cljs","^P",14,"^Z",["^R",[["~$f"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",20,"^O",20,"^Y",1,"^12",true,"^Q",["^R",["^S",["^R",[["~$f"]]]]]],"~$monoid",["^ ","^J",null,"^K",["^ ","^L","^B","^M",242,"^N",7,"^O",242,"^P",13,"^Q",["^R",["^S",["^R",[["~$op","^1J"]]]]],"^V","Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it."],"^A","~$clojure.core.reducers/monoid","^X",false,"^L","clojure/core/reducers.cljs","^P",13,"^Z",["^R",[["^2R","^1J"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",242,"^O",242,"^Y",2,"^12",true,"^Q",["^R",["^S",["^R",[["^2R","^1J"]]]]],"^V","Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it."],"^1[",["^ ","^J",null,"^K",["^ ","^L","^B","^M",47,"^N",4,"^O",47,"^P",13,"~:protocol","^1A","^V",null,"^Q",["^R",["^S",["^R",[["^T","~$n","^20","^21"]]]]]],"^2T","^1A","^A","~$clojure.core.reducers/coll-fold","^X",false,"^L","clojure/core/reducers.cljs","^P",13,"^Z",["^R",[["^T","~$n","^20","^21"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",46,"^O",47,"^Y",4,"^12",true,"^Q",["^R",["^S",["^R",[["^T","~$n","^20","^21"]]]]],"^V",null],"~$foldvec",["^ ","^J",null,"^K",["^ ","^L","^B","^M",273,"^N",8,"^O",273,"^P",15,"^1R",true,"^Q",["^R",["^S",["^R",[["~$v","~$n","^20","^21"]]]]]],"^1R",true,"^A","~$clojure.core.reducers/foldvec","^X",false,"^L","clojure/core/reducers.cljs","^P",15,"^Z",["^R",[["~$v","~$n","^20","^21"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",273,"^O",273,"^Y",4,"^12",true,"^Q",["^R",["^S",["^R",[["~$v","~$n","^20","^21"]]]]]],"~$fjfork",["^ ","^J",null,"^K",["^ ","^L","^B","^M",26,"^N",8,"^O",26,"^P",14,"^1R",true,"^Q",["^R",["^S",["^R",[["^1S"]]]]]],"^1R",true,"^A","~$clojure.core.reducers/fjfork","^X",false,"^L","clojure/core/reducers.cljs","^P",14,"^Z",["^R",[["^1S"]]],"^11",null,"^[",["^R",[null,null]],"^N",1,"^M",26,"^O",26,"^Y",1,"^12",true,"^Q",["^R",["^S",["^R",[["^1S"]]]]]],"~$t_clojure$core$reducers2359",["^ ","^2I",3,"^1=",["^6",["^1>","^1?","^1@"]],"^A","~$clojure.core.reducers/t_clojure$core$reducers2359","^L","clojure/core/reducers.cljs","^2J",true,"^1<",true,"^N",6,"^M",72,"^2K",false,"^1B",["^6",["^1>","^1?","^1@"]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ "],"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["^2S","^7","~$x","^1A","^2W","^2Y","^2<","^8","^2M","^9","^15","^17","^1T","^:","^1E","^1;","^2D","^1R","~:else","^1X","^1V","^2T","^1K","^1G","^1=","^;","~:ns","^<","^A","^1F","^1J","^=","^X","^1Q","^B","^1U","^L","~$v","^P","^W","^20","^1N","^Z","^2?","^U","^1W","^2E","^2A","^21","^1S","^[","^1<","^2G","^N","^2;","^2>","~:author","~$n","^16","^2U","^1:","^2=","^1D","^1C","^2@","^>","^1Z","^T","^2B","^2F","^1?","^M","^1Y","^18","^10","^2R","^1O","^2N","^2C","^O","^2P","^?","^13","^19","^1H","^14","^Y","^@","^Q","^1B","^2O","^V","^1I","^2Q","^1M","^22","^1P","^1>","~:test","^1[","^1L","^2V","^2X","^1@","~$f"]],"~:order",["^2P","^1R","^35","^A","^L","^P","^N","^M","^O","^Q","^V","^37","^B","^36","^2O","~$f","^1V","^1U","^2Y","^2X","^1S","^1T","^1Q","^10","^W","^7","^X","^Y","^Z","^[","^T","^U","^34","^1A","^1X","^1Y","^22","^1W","^1Z","^1[","~$n","^20","^21","^2U","^2T","^2G","^2F","^18","^1H","^1I","^1=","^1<","^1C","^1B","^1>","^1?","^1@","^1G","^1D","^19","^17","^1E","^1F","^1;","^2<","^2;","^14","^9","^1:","^:","^2N","^@","^1N","^2M","^?","^1P","^=","^1O","^<","^13","^8","^2E","^>","^2C","^1K","^1L","^2D","^2A","^2B","^2@","^1M","^;","^1J","^2?","^2=","^2>","~$x","^16","^15","^2S","^2Q","^2R","^2W","^2V","~$v"]],"^V","A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info."]