["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Date",["^ ","~$prototype",["^ ","~$valueOf",["^ "]]],"~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",["~$+","~$*","~$bit-xor","~$bit-or","~$bit-count","~$unsigned-bit-shift-right"]],"~:name","~$clojure.test.check.random","~:imports",null,"~:requires",["^ ","~$doubles","~$clojure.test.check.random.doubles","^C","^C","~$longs","~$clojure.test.check.random.longs","^E","^E"],"~:uses",["^ ","^<","^E","^:","^E","^=","^E","~$*","^E","^;","^E","~$+","^E"],"~:defs",["^ ","~$mix-gamma-const-1",["^ ","~:meta",["^ ","~:file","^?","~:line",71,"~:column",16,"~:end-line",71,"~:end-column",33,"~:private",true],"^O",true,"^>","~$clojure.test.check.random/mix-gamma-const-1","^J","clojure/test/check/random.cljs","^N",33,"^L",1,"^K",71,"^M",71,"~:tag","~$any"],"~$make-java-util-splittable-random",["^ ","~:protocol-inline",null,"^I",["^ ","^J","^?","^K",123,"^L",7,"^M",123,"^N",39,"~:arglists",["~#list",["~$quote",["^V",[["~$seed"]]]]]],"^>","~$clojure.test.check.random/make-java-util-splittable-random","~:variadic",false,"^J","clojure/test/check/random.cljs","^N",39,"~:method-params",["^V",[["^X"]]],"~:protocol-impl",null,"~:arglists-meta",["^V",[null,null]],"^L",1,"^K",123,"^M",123,"~:max-fixed-arity",1,"~:fn-var",true,"^U",["^V",["^W",["^V",[["^X"]]]]]],"~$rand-long",["^ ","^T",null,"^I",["^ ","^J","^?","^K",20,"^L",4,"^M",20,"^N",13,"~:protocol","~$clojure.test.check.random/IRandom","~:doc","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^U",["^V",["^W",["^V",[["~$rng"]]]]]],"^15","^16","^>","~$clojure.test.check.random/rand-long","^Z",false,"^J","clojure/test/check/random.cljs","^N",13,"^[",["^V",[["^18"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",19,"^M",20,"^12",1,"^13",true,"^U",["^V",["^W",["^V",[["^18"]]]]],"^17","Returns a random goog.math.Long based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$mix-64",["^ ","^T",null,"^I",["^ ","^J","^?","^K",62,"^L",17,"^M",62,"^N",23,"^O",true,"^U",["^V",["^W",["^V",[["~$n"]]]]]],"^O",true,"^>","~$clojure.test.check.random/mix-64","^Z",false,"^J","clojure/test/check/random.cljs","^N",23,"^[",["^V",[["~$n"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",62,"^M",62,"^12",1,"^13",true,"^U",["^V",["^W",["^V",[["~$n"]]]]]],"~$golden-gamma",["^ ","^I",["^ ","^J","^?","^K",120,"^L",16,"^M",120,"^N",28,"^O",true],"^O",true,"^>","~$clojure.test.check.random/golden-gamma","^J","clojure/test/check/random.cljs","^N",28,"^L",1,"^K",120,"^M",120,"^Q","^R"],"~$mix-gamma-const-2",["^ ","^I",["^ ","^J","^?","^K",72,"^L",16,"^M",72,"^N",33,"^O",true],"^O",true,"^>","~$clojure.test.check.random/mix-gamma-const-2","^J","clojure/test/check/random.cljs","^N",33,"^L",1,"^K",72,"^M",72,"^Q","^R"],"~$mix-64-const-2",["^ ","^I",["^ ","^J","^?","^K",60,"^L",16,"^M",60,"^N",30,"^O",true],"^O",true,"^>","~$clojure.test.check.random/mix-64-const-2","^J","clojure/test/check/random.cljs","^N",30,"^L",1,"^K",60,"^M",60,"^Q","^R"],"~$bxoubsr",["^ ","^T",null,"^I",["^ ","^J","^?","^K",54,"^L",17,"^M",54,"^N",24,"^O",true,"^U",["^V",["^W",["^V",[["~$x","~$n"]]]]],"^17","Performs (-> x (unsigned-bit-shift-right n) (bit-xor x))."],"^O",true,"^>","~$clojure.test.check.random/bxoubsr","^Z",false,"^J","clojure/test/check/random.cljs","^N",24,"^[",["^V",[["~$x","~$n"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",54,"^M",54,"^12",2,"^13",true,"^U",["^V",["^W",["^V",[["~$x","~$n"]]]]],"^17","Performs (-> x (unsigned-bit-shift-right n) (bit-xor x))."],"~$make-random",["^ ","^T",null,"^I",["^ ","^J","^?","^K",140,"^L",7,"^M",140,"^N",18,"^U",["^V",["^W",["^V",[[],["^X"]]]]],"^17","Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol.","~:top-fn",["^ ","^Z",false,"^12",1,"^[",["^V",[[],["^X"]]],"^U",["^V",[[],["^X"]]],"^11",["^V",[null,null]]]],"^>","~$clojure.test.check.random/make-random","^Z",false,"^J","clojure/test/check/random.cljs","^N",18,"^1E",["^ ","^Z",false,"^12",1,"^[",["^V",[[],["^X"]]],"^U",["^V",[[],["^X"]]],"^11",["^V",[null,null]]],"^[",["^V",[[],["^X"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",140,"^M",140,"^12",1,"^13",true,"^U",["^V",[[],["^X"]]],"^17","Given an optional integer (or goog.math.Long) seed, returns an\n  implementation of the IRandom protocol."],"~$mix-gamma",["^ ","^T",null,"^I",["^ ","^J","^?","^K",75,"^L",17,"^M",75,"^N",26,"^O",true,"^U",["^V",["^W",["^V",[["~$n"]]]]]],"^O",true,"^>","~$clojure.test.check.random/mix-gamma","^Z",false,"^J","clojure/test/check/random.cljs","^N",26,"^[",["^V",[["~$n"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",75,"^M",75,"^12",1,"^13",true,"^U",["^V",["^W",["^V",[["~$n"]]]]]],"~$mix-gamma-const-3",["^ ","^I",["^ ","^J","^?","^K",73,"^L",16,"^M",73,"^N",33,"^O",true],"^O",true,"^>","~$clojure.test.check.random/mix-gamma-const-3","^J","clojure/test/check/random.cljs","^N",33,"^L",1,"^K",73,"^M",73,"^Q","^R"],"~$split-n",["^ ","^T",null,"^I",["^ ","^J","^?","^K",37,"^L",4,"^M",37,"^N",11,"^15","^16","^17","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^U",["^V",["^W",["^V",[["^18","~$n"]]]]]],"^15","^16","^>","~$clojure.test.check.random/split-n","^Z",false,"^J","clojure/test/check/random.cljs","^N",11,"^[",["^V",[["^18","~$n"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",19,"^M",37,"^12",2,"^13",true,"^U",["^V",["^W",["^V",[["^18","~$n"]]]]],"^17","Returns a collection of `n` RNGs, which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$next-rng",["^ ","^I",["^ ","^J","^?","^K",130,"^L",16,"^M",130,"^N",24,"^O",true],"^O",true,"^>","~$clojure.test.check.random/next-rng","^J","clojure/test/check/random.cljs","^N",24,"^L",1,"^K",130,"^M",130,"^Q","~$function"],"~$hex-long",["^ ","^T",null,"^I",["^ ","^J","^?","^K",49,"^L",17,"^M",49,"^N",25,"^O",true,"^U",["^V",["^W",["^V",[["~$s"]]]]],"^17","Helper for defining constants."],"^O",true,"^>","~$clojure.test.check.random/hex-long","^Z",false,"^J","clojure/test/check/random.cljs","^N",25,"^[",["^V",[["~$s"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",49,"^M",49,"^12",1,"^13",true,"^U",["^V",["^W",["^V",[["~$s"]]]]],"^17","Helper for defining constants."],"~$rand-double",["^ ","^T",null,"^I",["^ ","^J","^?","^K",25,"^L",4,"^M",25,"^N",15,"^15","^16","^17","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^U",["^V",["^W",["^V",[["^18"]]]]]],"^15","^16","^>","~$clojure.test.check.random/rand-double","^Z",false,"^J","clojure/test/check/random.cljs","^N",15,"^[",["^V",[["^18"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",19,"^M",25,"^12",1,"^13",true,"^U",["^V",["^W",["^V",[["^18"]]]]],"^17","Returns a random double between 0.0 (inclusive) and 1.0 (exclusive)\n  based on the given immutable RNG.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$mix-64-const-1",["^ ","^I",["^ ","^J","^?","^K",59,"^L",16,"^M",59,"^N",30,"^O",true],"^O",true,"^>","~$clojure.test.check.random/mix-64-const-1","^J","clojure/test/check/random.cljs","^N",30,"^L",1,"^K",59,"^M",59,"^Q","^R"],"~$split",["^ ","^T",null,"^I",["^ ","^J","^?","^K",31,"^L",4,"^M",31,"^N",9,"^15","^16","^17","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument","^U",["^V",["^W",["^V",[["^18"]]]]]],"^15","^16","^>","~$clojure.test.check.random/split","^Z",false,"^J","clojure/test/check/random.cljs","^N",9,"^[",["^V",[["^18"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^K",19,"^M",31,"^12",1,"^13",true,"^U",["^V",["^W",["^V",[["^18"]]]]],"^17","Returns two new RNGs [rng1 rng2], which should generate\n  sufficiently independent random data.\n\n  Note: to maintain independence you should not call more than one\n  function in the IRandom protocol with the same argument"],"~$JavaUtilSplittableRandom",["^ ","~:num-fields",2,"~:protocols",["^9",["^16"]],"^>","~$clojure.test.check.random/JavaUtilSplittableRandom","^J","clojure/test/check/random.cljs","^N",34,"~:type",true,"^L",10,"^K",91,"~:record",false,"^M",91,"~:skip-protocol-flag",null],"~$IRandom",["^ ","^I",["^ ","~:protocol-symbol",true,"^J","^?","^N",21,"^L",14,"^K",19,"~:protocol-info",["^ ","~:methods",["^ ","^14",[["^18"]],"^1R",[["^18"]],"^1V",[["^18"]],"^1K",[["^18","~$n"]]]],"^M",19,"^17",null,"~:jsdoc",["^V",["@interface"]]],"^24",true,"^>","^16","^J","clojure/test/check/random.cljs","^N",21,"^L",1,"^K",19,"^25",["^ ","^26",["^ ","^14",[["^18"]],"^1R",[["^18"]],"^1V",[["^18"]],"^1K",[["^18","~$n"]]]],"~:info",null,"^M",19,"^Q","^R","~:impls",["^9",["^1["]],"^17",null,"^27",["^V",["@interface"]]],"~$->JavaUtilSplittableRandom",["^ ","^T",null,"^I",["^ ","^1Z",["^9",["^16"]],"^J","^?","^N",34,"^L",10,"~:factory","~:positional","^K",91,"^M",91,"^U",["^V",["^W",["^V",[["~$gamma","~$state"]]]]],"^22",null],"^1Z",["^9",["^16"]],"^>","~$clojure.test.check.random/->JavaUtilSplittableRandom","^Z",false,"^J","clojure/test/check/random.cljs","^N",34,"^[",["^V",[["^2=","^2>"]]],"^10",null,"^11",["^V",[null,null]],"^L",1,"^2;","^2<","^K",91,"^M",91,"^12",2,"^13",true,"^U",["^V",["^W",["^V",[["^2=","^2>"]]]]],"^22",null]],"~:require-macros",["^ "],"~:cljs.analyzer/constants",["^ ","~:seen",["^9",["^2=","^2>","~:seed","~:state","~:returned"]],"~:order",["^2=","^2>","^2C","^2D","^2E"]],"^17","Purely functional and splittable pseudo-random number generators."]