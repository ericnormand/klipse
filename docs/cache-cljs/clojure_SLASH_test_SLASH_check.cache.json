["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$ct","~$clojure.test.check.clojure-test","~$rose","~$clojure.test.check.rose-tree","~$clojure.test.check.impl","^=","^<","^<","~$clojure.test.check.generators","^>","~$gen","^>","~$clojure.test.check.random","^@","^:","^:","~$random","^@"],"~:uses",["^ ","~$exception-like?","^=","~$get-current-time-millis","^="],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^6","~:line",79,"~:column",8,"~:end-line",79,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^P",[["~$rose-tree"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"^N",true,"^5","~$clojure.test.check/shrink-loop","~:variadic",false,"^I","clojure/test/check.cljc","^M",19,"~:method-params",["^P",[["^R"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^K",1,"^J",79,"^L",79,"~:max-fixed-arity",1,"~:fn-var",true,"^O",["^P",["^Q",["^P",[["^R"]]]]],"^S","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"~$failure",["^ ","^G",null,"^H",["^ ","^I","^6","^J",112,"^K",8,"^L",112,"^M",15,"^N",true,"^O",["^P",["^Q",["^P",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed"]]]]]],"^N",true,"^5","~$clojure.test.check/failure","^U",false,"^I","clojure/test/check.cljc","^M",15,"^V",["^P",[["^10","^11","^12","^13","^14"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^J",112,"^L",112,"^Y",5,"^Z",true,"^O",["^P",["^Q",["^P",[["^10","^11","^12","^13","^14"]]]]]],"~$make-rng",["^ ","^G",null,"^H",["^ ","^I","^6","^J",20,"^K",8,"^L",20,"^M",16,"^N",true,"^O",["^P",["^Q",["^P",[["^14"]]]]]],"^N",true,"^5","~$clojure.test.check/make-rng","^U",false,"^I","clojure/test/check.cljc","^M",16,"^V",["^P",[["^14"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^J",20,"^L",20,"^Y",1,"^Z",true,"^O",["^P",["^Q",["^P",[["^14"]]]]]],"~$complete",["^ ","^G",null,"^H",["^ ","^I","^6","^J",27,"^K",8,"^L",27,"^M",16,"^N",true,"^O",["^P",["^Q",["^P",[["^10","~$num-trials","^14"]]]]]],"^N",true,"^5","~$clojure.test.check/complete","^U",false,"^I","clojure/test/check.cljc","^M",16,"^V",["^P",[["^10","^19","^14"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^J",27,"^L",27,"^Y",3,"^Z",true,"^O",["^P",["^Q",["^P",[["^10","^19","^14"]]]]]],"~$not-falsey-or-exception?",["^ ","^G",null,"^H",["^ ","^I","^6","^J",32,"^K",8,"^L",32,"^M",32,"^N",true,"^O",["^P",["^Q",["^P",[["~$value"]]]]],"^S","True if the value is not falsy or an exception"],"^N",true,"^5","~$clojure.test.check/not-falsey-or-exception?","^U",false,"^I","clojure/test/check.cljc","^M",32,"^V",["^P",[["^1<"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^J",32,"^L",32,"^Y",1,"^Z",true,"^O",["^P",["^Q",["^P",[["^1<"]]]]],"^S","True if the value is not falsy or an exception"],"~$quick-check",["^ ","^G",null,"^H",["^ ","^I","^6","^J",37,"^K",7,"^L",37,"^M",18,"^O",["^P",["^Q",["^P",[["~$num-tests","^10","~$&",["^ ","~:keys",["^14","~$max-size"],"~:or",["^ ","^1A",200]]]]]]],"^S","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  ","~:top-fn",["^ ","^U",true,"^Y",2,"^V",[["^P",["^1?","^10",["^ ","^1@",["^14","^1A"],"^1B",["^ ","^1A",200]]]]],"^O",["^P",[["^1?","^10","~$&",["^ ","^1@",["^14","^1A"],"^1B",["^ ","^1A",200]]]]],"^X",["^P",[null]]]],"^5","~$clojure.test.check/quick-check","^U",true,"^I","clojure/test/check.cljc","^M",18,"^1C",["^ ","^U",true,"^Y",2,"^V",[["^P",["^1?","^10",["^ ","^1@",["^14","^1A"],"^1B",["^ ","^1A",200]]]]],"^O",["^P",[["^1?","^10","~$&",["^ ","^1@",["^14","^1A"],"^1B",["^ ","^1A",200]]]]],"^X",["^P",[null]]],"^V",[["^P",["^1?","^10",["^ ","^1@",["^14","^1A"],"^1B",["^ ","^1A",200]]]]],"^W",null,"^X",["^P",[null]],"^K",1,"^J",37,"^L",37,"^Y",2,"^Z",true,"^O",["^P",[["^1?","^10","~$&",["^ ","^1@",["^14","^1A"],"^1B",["^ ","^1A",200]]]]],"^S","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  "],"~$smallest-shrink",["^ ","^G",null,"^H",["^ ","^I","^6","^J",72,"^K",8,"^L",72,"^M",23,"^N",true,"^O",["^P",["^Q",["^P",[["~$total-nodes-visited","~$depth","~$smallest"]]]]]],"^N",true,"^5","~$clojure.test.check/smallest-shrink","^U",false,"^I","clojure/test/check.cljc","^M",23,"^V",["^P",[["^1F","^1G","^1H"]]],"^W",null,"^X",["^P",[null,null]],"^K",1,"^J",72,"^L",72,"^Y",3,"^Z",true,"^O",["^P",["^Q",["^P",[["^1F","^1G","^1H"]]]]]]],"~:require-macros",["^ "],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:args","~:shrunk","~:total-nodes-visited","~:num-tests","~:max-size","~:seed","~:fail","~:result","~:smallest","~:failing-size","~:depth"]],"~:order",["^1T","^1P","^1R","^1Q","^1M","^1O","^1W","^1U","^1V","^1S","^1N"]],"^S",null]