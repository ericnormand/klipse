["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$cljs.test$macros","~:imports",null,"~:requires",["^ ","~$env","~$cljs.env","^<","^<","~$ana","~$cljs.analyzer","^>","^>","~$ana-api","~$cljs.analyzer.api","^@","^@"],"~:cljs.spec/speced-vars",[],"~:uses",null,"~:defs",["^ ","~$are",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","~$cljs.test","~:end-column",14,"~:top-fn",["^ ","~:variadic",true,"~:max-fixed-arity",4,"~:method-params",[["~#list",["~$&form","~$&env","~$argv","~$expr","~$args"]]],"~:arglists",["^N",[["^O","^P","^Q","^R","~$&","^S"]]],"~:arglists-meta",["^N",[null]]],"~:column",11,"~:line",168,"~:macro",true,"~:end-line",168,"^T",["^N",["~$quote",["^N",[["^Q","^R","~$&","^S"]]]]],"~:doc","Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers."],"^7","~$cljs.test$macros/are","^K",true,"^G","cljs/test.cljc","^I",14,"^J",["^ ","^K",true,"^L",4,"^M",[["^N",["^O","^P","^Q","^R","^S"]]],"^T",["^N",[["^O","^P","^Q","^R","~$&","^S"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^Q","^R","^S"]]],"~:protocol-impl",null,"^U",["^N",[null]],"^V",1,"^W",168,"^X",true,"^Y",168,"^L",4,"~:fn-var",false,"^T",["^N",[["^O","^P","^Q","^R","~$&","^S"]]],"^[","Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers."],"~$ns?",["^ ","^E",null,"^F",["^ ","^G","^H","^W",246,"^V",7,"^Y",246,"^I",10,"^T",["^N",["^Z",["^N",[["~$x"]]]]]],"^7","~$cljs.test$macros/ns?","^K",false,"^G","cljs/test.cljc","^I",10,"^M",["^N",[["~$x"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",246,"^Y",246,"^L",1,"^12",true,"^T",["^N",["^Z",["^N",[["~$x"]]]]]],"~$test-all-vars",["^ ","^E",null,"^F",["^ ","^G","^H","^W",335,"^V",11,"^Y",335,"^I",24,"^X",true,"^T",["^N",["^Z",["^N",[[["^Z","~$ns","~:as","~$form"]]]]]],"^[","Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures."],"^7","~$cljs.test$macros/test-all-vars","^K",false,"^G","cljs/test.cljc","^I",24,"^M",["^N",[["^O","^P","~$p__2673"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",335,"^X",true,"^Y",335,"^L",3,"^12",false,"^T",["^N",["^Z",["^N",[[["^Z","^16","^17","^18"]]]]]],"^[","Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures."],"~$run-all-tests",["^ ","^E",null,"^F",["^ ","^G","^H","^I",24,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P"],["^O","^P","~$re"],["^O","^P","^1<","^;"]]],"^T",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^U",["^N",[null,null,null]]],"^V",11,"^W",298,"^X",true,"^Y",298,"^T",["^N",["^Z",["^N",[[],["^1<"],["^1<","^;"]]]]],"^[","Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested."],"^7","~$cljs.test$macros/run-all-tests","^K",false,"^G","cljs/test.cljc","^I",24,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^T",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^U",["^N",[null,null,null]]],"^M",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^11",null,"^U",["^N",[null,null,null]],"^V",1,"^W",298,"^X",true,"^Y",298,"^L",4,"^12",false,"^T",["^N",[["^O","^P"],["^O","^P","^1<"],["^O","^P","^1<","^;"]]],"^[","Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested."],"~$assert-any",["^ ","^E",null,"^F",["^ ","^G","^H","^W",45,"^V",7,"^Y",45,"^I",17,"^T",["^N",["^Z",["^N",[["~$msg","^18"]]]]],"^[","Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols."],"^7","~$cljs.test$macros/assert-any","^K",false,"^G","cljs/test.cljc","^I",17,"^M",["^N",[["^1?","^18"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",45,"^Y",45,"^L",2,"^12",true,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols."],"~$testing",["^ ","^E",null,"^F",["^ ","^G","^H","^I",18,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","~$string","~$body"]]],"^T",["^N",[["^O","^P","^1B","~$&","^1C"]]],"^U",["^N",[null]]],"^V",11,"^W",192,"^X",true,"^Y",192,"^T",["^N",["^Z",["^N",[["^1B","~$&","^1C"]]]]],"^[","Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest)."],"^7","~$cljs.test$macros/testing","^K",true,"^G","cljs/test.cljc","^I",18,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^1B","^1C"]]],"^T",["^N",[["^O","^P","^1B","~$&","^1C"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^1B","^1C"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",192,"^X",true,"^Y",192,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^1B","~$&","^1C"]]],"^[","Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest)."],"~$assert-expr",["^ ","^7","~$cljs.test$macros/assert-expr","^G","cljs/test.cljc","^W",66,"^V",1,"^Y",66,"^I",22,"^F",["^ ","^G","^H","^W",66,"^V",11,"^Y",66,"^I",22],"~:tag","~$cljs.core/MultiFn"],"~$async",["^ ","^E",null,"^F",["^ ","^G","^H","^I",16,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","~$done","^1C"]]],"^T",["^N",[["^O","^P","^1J","~$&","^1C"]]],"^U",["^N",[null]]],"^V",11,"^W",224,"^X",true,"^Y",224,"^T",["^N",["^Z",["^N",[["^1J","~$&","^1C"]]]]],"^[","Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))"],"^7","~$cljs.test$macros/async","^K",true,"^G","cljs/test.cljc","^I",16,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^1J","^1C"]]],"^T",["^N",[["^O","^P","^1J","~$&","^1C"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^1J","^1C"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",224,"^X",true,"^Y",224,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^1J","~$&","^1C"]]],"^[","Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))"],"~$is",["^ ","^E",null,"^F",["^ ","^G","^H","^I",13,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^T",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^U",["^N",[null,null]]],"^V",11,"^W",150,"^X",true,"^Y",150,"^T",["^N",["^Z",["^N",[["^18"],["^18","^1?"]]]]],"^[","Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re."],"^7","~$cljs.test$macros/is","^K",false,"^G","cljs/test.cljc","^I",13,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^T",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^U",["^N",[null,null]]],"^M",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",150,"^X",true,"^Y",150,"^L",4,"^12",false,"^T",["^N",[["^O","^P","^18"],["^O","^P","^18","^1?"]]],"^[","Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re."],"~$deftest",["^ ","^E",null,"^F",["^ ","^G","^H","^I",18,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","~$name","^1C"]]],"^T",["^N",[["^O","^P","^1O","~$&","^1C"]]],"^U",["^N",[null]]],"^V",11,"^W",206,"^X",true,"^Y",206,"^T",["^N",["^Z",["^N",[["^1O","~$&","^1C"]]]]],"^[","Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored."],"^7","~$cljs.test$macros/deftest","^K",true,"^G","cljs/test.cljc","^I",18,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^1O","^1C"]]],"^T",["^N",[["^O","^P","^1O","~$&","^1C"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^1O","^1C"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",206,"^X",true,"^Y",206,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^1O","~$&","^1C"]]],"^[","Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored."],"~$assert-predicate",["^ ","^E",null,"^F",["^ ","^G","^H","^W",25,"^V",7,"^Y",25,"^I",23,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...)."],"^7","~$cljs.test$macros/assert-predicate","^K",false,"^G","cljs/test.cljc","^I",23,"^M",["^N",[["^1?","^18"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",25,"^Y",25,"^L",2,"^12",true,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...)."],"~$function?",["^ ","^E",null,"^F",["^ ","^G","^H","^W",19,"^V",7,"^Y",19,"^I",16,"^T",["^N",["^Z",["^N",[["~$menv","~$x"]]]]],"^[","Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro)."],"^7","~$cljs.test$macros/function?","^K",false,"^G","cljs/test.cljc","^I",16,"^M",["^N",[["^1T","~$x"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",19,"^Y",19,"^L",2,"^12",true,"^T",["^N",["^Z",["^N",[["^1T","~$x"]]]]],"^[","Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro)."],"~$run-tests-block",["^ ","^E",null,"^F",["^ ","^G","^H","^I",26,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","~$env-or-ns","~$namespaces"]]],"^T",["^N",[["^O","^P","^1W","~$&","^1X"]]],"^U",["^N",[null]]],"^V",11,"^W",249,"^X",true,"^Y",249,"^T",["^N",["^Z",["^N",[["^1W","~$&","^1X"]]]]],"^[","Like test-vars, but returns a block for further composition and\n  later execution."],"^7","~$cljs.test$macros/run-tests-block","^K",true,"^G","cljs/test.cljc","^I",26,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^1W","^1X"]]],"^T",["^N",[["^O","^P","^1W","~$&","^1X"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^1W","^1X"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",249,"^X",true,"^Y",249,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^1W","~$&","^1X"]]],"^[","Like test-vars, but returns a block for further composition and\n  later execution."],"~$test-ns-block",["^ ","^E",null,"^F",["^ ","^G","^H","^W",344,"^V",11,"^Y",344,"^I",24,"^X",true,"^T",["^N",["^Z",["^N",[["^;",["^Z","^16","^17","^18"]]]]]],"^[","Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env."],"^7","~$cljs.test$macros/test-ns-block","^K",false,"^G","cljs/test.cljc","^I",24,"^M",["^N",[["^O","^P","^;","~$p__2678"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",344,"^X",true,"^Y",344,"^L",4,"^12",false,"^T",["^N",["^Z",["^N",[["^;",["^Z","^16","^17","^18"]]]]]],"^[","Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env."],"~$try-expr",["^ ","^E",null,"^F",["^ ","^G","^H","^W",136,"^V",11,"^Y",136,"^I",19,"^X",true,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this."],"^7","~$cljs.test$macros/try-expr","^K",false,"^G","cljs/test.cljc","^I",19,"^M",["^N",[["^O","^P","^1?","^18"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",136,"^X",true,"^Y",136,"^L",4,"^12",false,"^T",["^N",["^Z",["^N",[["^1?","^18"]]]]],"^[","Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this."],"~$use-fixtures",["^ ","^E",null,"^F",["^ ","^G","^H","^W",378,"^V",11,"^Y",378,"^I",23,"^X",true,"^T",["^N",["^Z",["^N",[["~$type","~$&","~$fns"]]]]],"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^24","^25"]]],"^T",["^N",[["^O","^P","^24","~$&","^25"]]],"^U",["^N",[null]]]],"^7","~$cljs.test$macros/use-fixtures","^K",true,"^G","cljs/test.cljc","^I",23,"^J",["^ ","^K",true,"^L",3,"^M",[["^N",["^O","^P","^24","^25"]]],"^T",["^N",[["^O","^P","^24","~$&","^25"]]],"^U",["^N",[null]]],"^M",[["^N",["^O","^P","^24","^25"]]],"^11",null,"^U",["^N",[null]],"^V",1,"^W",378,"^X",true,"^Y",378,"^L",3,"^12",false,"^T",["^N",[["^O","^P","^24","~$&","^25"]]]],"~$test-ns",["^ ","^E",null,"^F",["^ ","^G","^H","^I",18,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^T",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^U",["^N",[null,null]]],"^V",11,"^W",361,"^X",true,"^Y",361,"^T",["^N",["^Z",["^N",[["^16"],["^;",["^Z","^16","^17","^18"]]]]]],"^[","If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  "],"^7","~$cljs.test$macros/test-ns","^K",false,"^G","cljs/test.cljc","^I",18,"^J",["^ ","^K",false,"^L",4,"^M",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^T",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^U",["^N",[null,null]]],"^M",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",361,"^X",true,"^Y",361,"^L",4,"^12",false,"^T",["^N",[["^O","^P","^16"],["^O","^P","^;",["^Z","^16","^17","^18"]]]],"^[","If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  "],"~$test-all-vars-block",["^ ","^E",null,"^F",["^ ","^G","^H","^W",312,"^V",11,"^Y",312,"^I",30,"^X",true,"^T",["^N",["^Z",["^N",[[["^Z","^16"]]]]]]],"^7","~$cljs.test$macros/test-all-vars-block","^K",false,"^G","cljs/test.cljc","^I",30,"^M",["^N",[["^O","^P","~$p__2572"]]],"^11",null,"^U",["^N",[null,null]],"^V",1,"^W",312,"^X",true,"^Y",312,"^L",3,"^12",false,"^T",["^N",["^Z",["^N",[[["^Z","^16"]]]]]]],"~$run-tests",["^ ","^E",null,"^F",["^ ","^G","^H","^I",20,"^J",["^ ","^K",true,"^L",3,"^M",["^N",[["^O","^P"],["^O","^P","^1W"]]],"^T",["^N",[["^O","^P"],["^O","^P","^1W"],["^O","^P","^1W","~$&","^1X"]]],"^U",["^N",[null,null,null]]],"^V",11,"^W",284,"^X",true,"^Y",284,"^T",["^N",["^Z",["^N",[[],["^1W"],["^1W","~$&","^1X"]]]]],"^[","Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod."],"^7","~$cljs.test$macros/run-tests","^K",true,"^G","cljs/test.cljc","^I",20,"^J",["^ ","^K",true,"^L",3,"^M",["^N",[["^O","^P"],["^O","^P","^1W"]]],"^T",["^N",[["^O","^P"],["^O","^P","^1W"],["^O","^P","^1W","~$&","^1X"]]],"^U",["^N",[null,null,null]]],"^M",["^N",[["^O","^P"],["^O","^P","^1W"]]],"^11",null,"^U",["^N",[null,null,null]],"^V",1,"^W",284,"^X",true,"^Y",284,"^L",3,"^12",false,"^T",["^N",[["^O","^P"],["^O","^P","^1W"],["^O","^P","^1W","~$&","^1X"]]],"^[","Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod."]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","~$temp","~$clojure.template","^2A","^2A"],"^[",null]